## 一个故事类比浏览器中渲染原理

近期美术班级准备一个绘画作品展，班级老师决定让 html 小明，css 小美，js 小张三个人组成一个团队完成一幅画作为展示

其中每个人的职责：

- 小明：负责画图
- 小美：负责图色
- 小张：负责修改完成的作品

小明负责绘制一颗树的清单：

- 树干
- 枝丫
- 树叶

小美负责涂色的清单：

- 树叶：红色
- 树丫：青色
- 树干：灰色
- 树干：灰褐色
  ...

小张负责对作品的修改清单：

- 如果树干是灰色的修改为黑色
- 如果叶子是红色的修改为绿色

三个人开始工作了：

#### 绘制第一张图时他们采取的策略：

- 小明绘画，小美和小张一直等着
- 小明画完，小美先将涂色清单读取一遍，每个属性的涂色方案只取最后的方案，然后开始涂色，小张一直等着
- 小美涂完色，小张开始拿着画好的图对着修改清单修改
  做完后花了一天事件，三人商量这样可不行，太浪费时间了，他们优化了绘画策略，所以

#### 绘制第二张图时他们采取的策略：

- 三人同时工作，小明读取绘画清单开始绘画，小美开始读取清单，然后涂色，小张根据修改清单进行修改
- 不一会儿，画板开始变得乱七八糟，小明树丫还没画完，小美涂色清单已经读完，开始涂色，发现没有树丫就开始下一项，造成树丫涂色丢失，小张在小明和小美还没有画完画就开始修改，结果完工后，一幅幅面怒全非

#### 吸取前两次的教训，画第三幅画时，三人采取的策略是：

- 小明开始画画的同时，小美读取清单，小张等待
- 小明画完，小美开始涂色，小张等待
- 小美涂完色，小张开始修改
- 结果这种方式效率最高

## 浏览器中渲染过程与上面的故事类似

#### 简单来说

- html 负责整体结构
- css 负责样式
- js 负责修改结构和样式

### 浏览器渲染时

- 首先 html 转换为 dom 树，同时然后 css 转换为 css 树，因为两者之间不相互影响，js 等待
- 然后合并 dom 树和 css 树成渲染树，js 现在可以修改了，js 修改后就是最后呈现在浏览器上的界面
- 所以我们可以知道 html 解析和 css 解析是两个互不干扰的过程，css 解析不会阻塞 html 解析，但是渲染过程是需要页面的 html 和 css 都解析完成的

#### 当一个页面中有内嵌的 css 和 js 时，而且不止一个

- 如果 js 在上，首先解析执行 js；如果 css 在上解析 css 和 html 然后合成渲染树，js 解析后渲染页面
- 如果有多个就重复上面的操作

#### 如果有外部链接的 css 和 js

- 和上面大致相同，唯一不同的是下载 css 会花费时间，当这个过程没有完成，就不会渲染页面，但是遇到 js 会解析执行 js
