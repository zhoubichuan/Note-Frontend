## 小程序与普通网页开发的区别
1. 网页开发渲染线程和脚本线程是一个进程。而小程序二者是分开的，分别运行在不同的线程。
2. 网页开发者可以操作DOM和BOM。小程序缺少操作DOM和BOM的方法。导致了例如JQ、Zepto等，在小程序中无法运行。
3. 小程序的运行环境与nodejs环境也不相同，所以一些npm的包在小程序中也是无法运行的。
- 从小程序基础库版本2.2.1开始支持使用npm安装第三方包。
## 小程序的开发流程
1. 注册小程序账号
    > 为了获取AppID，AppID就像是我们的身份证一样，是唯一的而且很重要，后续的所有开发流程会基于这个 AppID 来完成。
  - 直接在微信小程序的官网注册
  - 通过微信公众号注册
    > 条件是已经有微信公众号(并且是企业级，个人不可以)
    > 优点是如果公众号已经认证过了，小程序不需要再次认证，省去了认证的时间和费用
2. 安装开发者工具
3. 开发/测试/上传代码（上传到微信服务器）
4. 提交审核
5. 发布上线 发布小程序以后，我们才可以在微信中搜索到我们开发的小程序
6. 错误查询/性能监控 登录官网 -> 开发 -> 运维中心

## 如何让vscode支持编写小程序代码
> https://www.jianshu.com/p/27aaa647c5c5

## 微信开发者工具的安装及使用

## git版本管理

## 注意事项
1. 小程序项目中不能嵌套小程序项目
2. 创建小程序项目，不能是云开发、代码块
## 快速创建一个小程序
- 有AppID  我们可以在管网 -> 开发 -> 开发设置 中找到AppID
- 没有AppID 我们可以使用小程序提供的测试号开发 （不能上传代码，只做练习用）

## 小程序目录结构
1. pages 这里的每一个文件夹都代表一个小程序的页面
2. app.js 全局逻辑代码
3. app.josn 全局配置文件
4. app.wxss 全局样式文件

## 小程序4种文件类型
1. js 逻辑文件
2. json 配置文件
3. wxml(WeiXin Markup Language),是小程序框架设计的一套标签语言，结合小程序的基础组件、事件系统，可以构建出页面结构。
  - 与html的区别是他不能使用我们熟悉的div、span、p等标签，而是使用小程序为我们提供的各种组件
4. wxss(WeiXin Style Sheets)小程序样式文件
  
## js
1. 脚本的执行顺序
> 当 app.js 执行结束后，小程序会按照开发者在 app.json 中定义的 pages 的顺序，逐一执行。
2. 作用域
> 同浏览器中运行的脚本文件有所不同，小程序的脚本的作用域同 NodeJS 更为相似。在文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会互相影响

## wxss
1. 小程序的尺寸单位rpx，**`可以根据屏幕宽度进行自适应`**。规定屏幕宽度750rpx。如在iPhone6上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素
2. 定义在app.wxss中的样式为全局样式，它会被注入到每个小程序的每个页面。在page的wxss文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖app.wxss中相同的配置（就近原则）
3. 样式导入
在CSS中，开发者可以这样引用另一个样式文件：@import url('./test.css')
在小程序中，我们依然可以实现样式的引用，样式引用是这样写：@import './test.wxss'
官方样式库：https://github.com/Tencent/weui-wxss
4. 选择器
小程序目前支持的选择器有：（文档中是这样写到的，但实际支持的选择器不止这些，我们可以在开发中尝试使用一些其他选择器，不行再换一种方式）
1. .class
2. #id
3. element
4. element,element
5. ::after
6. ::before

## 组件
- 组件的定义
> 组件（Component）就是把一些常见的网页拆分成不同的部分，进行封装，目的是为了实现代码的复用。
> 小程序给我们提供了丰富的基础组件，我们只需要像搭积木一样，组合各种组件拼合成自己的小程序。
> 我们除了可以使用小程序给我们提供的组件外，小程序也允许我们开发自己的组件(自定义组件)
- 组件有什么优点呢?
1. 可组合性
2. 可重用性
3. 可维护性
## view 组件
## image 组件
> image组件默认宽度300px、高度225px(320*240)
**注意**：如果我们想让image组件上的高度随宽度等比例自适应，在小程序中设置height="auto"是不起作用的，这样设置可能会造成图片不显示。解决的方法是设置mode="widthFix"。
> 要学习灵活运用mode
> mode 有效值 参见文档 -> 组件 -> image
## text 组件
> 除了文本节点以外的其他节点都无法长按选中
## 数据绑定
1. 内容
```
<view>{{message}}</view>
Page({
	data: {
		message: 'Hello World'
	}
})
```
2. 属性（需要在双引号之内）
```
<view id="{{id}}"></view>
```
3. 运算符
```
<view hidden="{{flag ? true : false}}"> Hidden </view>
```
5. 其它
```
<view>{{"hello" + name}}</view>
<view>{{name}} {{age}}</view>
```
## 事件绑定及事件处理函数
> 事件是视图层到逻辑层的通讯方式,可以将用户的行为反馈到逻辑层进行处理。
> 事件对象可以携带额外信息，如id，dataset
- 事件分类
  -  冒泡事件
  -  非冒泡事件
 - 事件绑定
   - 事件绑定的写法同组件的属性，以key、value的形式。
   > key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtap
   > **bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡**
- 事件对象
type 代表事件的类型
timeStamp页面打开到触发事件所经过的毫秒数
target 触发事件的源组件
currentTarget 事件绑定的当前组件
	- id 事件源组件的id
	- tagName 当前组件的类型
	- dataset 事件源组件上有data-开头的自定义属性组成的集合
> 以data-开头，多个单词有连字符-连接，不能有大写（大写会自动转成小写）如data-element-type，最终在event.currentTarget.dataset中会将连字符转成驼峰elementType。

## 页面跳转
- wx.navigateTo
## page.json-window
```
 "window":{
    "navigationBarBackgroundColor": "#e94840",   // 导航栏背景颜色  16进制
    "navigationBarTitleText": "珠峰培训", // 导航栏标题文字
    "navigationBarTextStyle":"black"  // 导航栏标题颜色，仅支持black/white
}
```
## page.json-networkTimeout
```
"networkTimeout": {
    "request": 20000,
    "connectSocket": 20000,
    "uploadFile": 20000,
    "downloadFile": 20000
  }
```

## image 组件
> image组件默认宽度300px、高度225px(320*240)

**注意**：如果我们想让image组件上的高度随宽度等比例自适应，在小程序中设置height="auto"是不起作用的，这样设置可能会造成图片不显示。解决的方法是设置mode="widthFix"。
> 要学习灵活运用mode
> mode 有效值 参见文档 -> 组件 -> image

## swiper 组件
1. indicator-dots  false 是否显示面板指示点
2. indicator-color rgba 指示点颜色
3. indicator-active-color #000 当前选中的指示点颜色
4. autoplay false 是否自动切换
5. interval 5000 自动切换时间间隔
6. duration 500 滑动动画时长
7. circular false 是否采用衔接滑动
8. vertical false 滑动方向是否为纵向

- swiper-item 仅可放置在swiper组件中，宽高自动设置为100%。**给swiper-item设置高度不起作用，要给swiper设置高度才有用**

## 列表渲染 wx:for
> 在组件上使用wx:for控制属性绑定一个数组，既可使用数组中各项的数据重复渲染该组件。
> 默认数组的当前项的下标变量名默认为index，数组当前项的变量默认为item
- 使用 wx:for-item 可以指定数组当前元素的变量名
- 使用 wx:for-index 可以指定数组当前下标的变量名
- wx:for 也可以嵌套
- wx:key 
> wx:key的意义是为列表中遍历的每一个元素指定一个唯一的标识。当数据改变触发渲染层重新渲染的时候，确保使组件保持自身状态并提高列表渲染时的效率。
1. 如果被遍历的数组中的元素是object，我们可以使用它的某一个值，这个值必须是不重复的数组或者字符串。
2. 如果被遍历的数组中的元素是数组或者是字符串 *this，代表在for循环中的item本身。

## block 标签
> 渲染一个包含多节点的结构块，实际渲染中并不会显示出<block>标签
```
<block wx:for="{{[1, 2, 3]}}">
  <view> {{index}}: </view>
  <view> {{item}} </view>
</block>

```
## app.json-tabBar
```
 "tabBar": { 
    "color": "#7a7e83", // 未被选中时的文字颜色
    "selectedColor": "#e94840", // 被选中时的文字颜色
    "borderStyle": "black", // tabbar上边框的颜色，仅支持black/white 
    "position": "bottom", // tabbar位置，仅支持bottom/top 默认bottom
    "backgroundColor": "#fff",
    "list": [{ // length 不能小于2个或大于五个
      "pagePath":"pages/index/index",
      "iconPath": "images/home2.png", // 可选
      "selectedIconPath": "images/home.png", // 可选
      "text": "首页"
    },{
      "pagePath": "pages/my/my",
      "iconPath": "images/my2.png", // 可选
      "selectedIconPath": "images/my.png", // 可选
      "text": "我的"
    }]
  }
```
## 获取用户信息
- 如果只是想显示用户的信息，我们是不需要用户授权的，只需要使用<open-data>
- 如果我们想在JS中拿到用户的信息，就需要用户授权。
1. 需要在页面加入<button>组件，设置属性open-type=“getUserInfo”，绑定getUserInfo事件回调
2. wx.getUserInfo()可以在用户已经授权过的情况下获得用户信息
3. 判断用户是否已经授权wx.getSetting()
## 条件渲染 wx:if
> 判断是否需要渲染该代码块
1. wx:if
2. wx:elif
3. wx:else
## wx:if 与hidden
> wx:if是惰性的，如果在初始渲染条件为false，框架什么也不做，在条件第一次变成true的时候才开始局部渲染。
> hidden 组件始终会被渲染，只是简单的控制显示与隐藏。
> 如果需要频繁切换的情况下，用hidden更好，如果在运行时条件不大可能改变wx:if较好。
## button 组件
## 去除button的默认样式
```css
 .btn,.btn::after{
     padding:0;
     background:none;
     border:none;
     content:none;
 }
```
## 页面跳转
- wx.switchTab 跳转到tabBar页面，并关闭其他所有tabBar页面
- wx.navigateTo 保留当前页面，跳转到应用内的某个页面。**但是不能跳转到tabBar页面**可以使用wx.navigateBack返回原页面
## 页面的生命周期
- onLoad 监听页面加载，**只在页面初始化时加载一次**
- onShow 监听页面显示，**每次显示页面都会执行**，可以多次执行
- onReady 监听页面初次渲染完成
- onHide 监听页面隐藏
- onUnload 监听页面卸载
## 转发
> 只有在页面js中监听了onShareAppMessage事件处理函数，右上角菜单才会显示“转发”按钮。
- 自定义转发内容
> 只需要在事件处理函数中return 一个对象，实例如下
```
onShareAppMessage() {
    return {
      title: '自定义转发标题',
      path: '/page/user?id=123',
      imageUrl: ''
    }
  }
```
- 默认转发内容
> 如果我们没有在事件处理函数中return一个对象，小程序会默认把当前页面的标题、路径及页面截图返回


## 后台接口
- 轮播图 https://www.easy-mock.com/mock/5c2b2992f2332405dd956d1e/zhufeng/getSliders
- 课程列表 https://www.easy-mock.com/mock/5c2b2992f2332405dd956d1e/zhufeng/getLessons

## 向后台发送数据请求
- 向后台发送请求必须满足两个条件
1. 必须是https请求，因为小程序只允许发送https请求
2. 必须在管理后台中配置合法域名  登录管理后台 -> 开发 -> 开发设置
> 如果在开发过程中，我们不想让开发者工具检测我们的接口，我们可以在开发者工具的工具栏 -> 详情 -> 在最下方勾选不校验合法域名选项

- wx.request 专门用于向服务器发送请求，函数接收一个Object对象
```
    wx.request({
      url: 'https://',
      method: 'GET',
      data: {},
      dataType: 'json',
      header: {
        'content-type': 'application/json'
      },
      success(res){
        // 成功后的回调
      },
      fail(err){
       // 失败后的回调
      },
      complete(){
        console.log('不管成功失败都会调用');
      }
    });
```
- fail 接口调用失败的问题 
> 服务器返回的404、500等状态码并不会让小程序执行fail的回调函数，只有接口调用失败时才会执行fail回调函数。
- success 接口调用成功的回调函数
1. success返回的对象中data才是我们服务器返回的数据
2. this指向问题

## showToast

## showMode

## getApp();

## export import
> import 导入时必须使用相对路径
## 封装request

## web-view
- web-view 组件是一个可以用来承载网页的容器，会自动铺满整个小程序页面。**个人类型与海外类型的小程序暂不支持使用。**
```
<web-view src="https://mp.weixin.qq.com/"></web-view>
```
- 如果想在H5页面调用小程序提供的一些接口就必须在H5页面中引入如下JS
```
<scriptsrc="https://res.wx.qq.com/open/js/jweixin-1.3.2.js"></script>
```
## 事件绑定及事件处理函数
> 事件是视图层到逻辑层的通讯方式,可以将用户的行为反馈到逻辑层进行处理。
> 事件对象可以携带额外信息，如id，dataset
- 事件分类
  -  冒泡事件
  -  非冒泡事件
 - 事件绑定
   - 事件绑定的写法同组件的属性，以key、value的形式。
   > key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtap
   > **bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡**
- 事件对象
type 代表事件的类型
timeStamp页面打开到触发事件所经过的毫秒数
target 触发事件的源组件
currentTarget 事件绑定的当前组件
	- id 事件源组件的id
	- tagName 当前组件的类型
	- dataset 事件源组件上有data-开头的自定义属性组成的集合
> 以data-开头，多个单词有连字符-连接，不能有大写（大写会自动转成小写）如data-element-type，最终在event.currentTarget.dataset中会将连字符转成驼峰elementType。

## 页面跳转
- wx.switchTab 跳转到tabBar页面，并关闭其他所有tabBar页面
- wx.navigateTo 保留当前页面，跳转到应用内的某个页面。**但是不能跳转到tabBar页面**可以使用wx.navigateBack返回原页面
- wx.navigateBack
```
wx.navigateBack({
  delta: 2  // 如果返回上一页可以不写
})
```
- wx.redirectTo 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。
- wx.reLaunch 关闭所有页面，打开到应用内的某个页面
## chooseAddress
```
onChooseAddr(){
    wx.chooseAddress({
      success(res) {
        console.log(res.userName)
        console.log(res.postalCode)
        console.log(res.provinceName)
        console.log(res.cityName)
        console.log(res.countyName)
        console.log(res.detailInfo)
        console.log(res.nationalCode)
        console.log(res.telNumber)
      }
    })
  },
```
## 地理位置
1. chooseLocation
2. getLocation
3. openLocation
## 创建自定义组件
1. 新建一个components文件夹，用于存放我们以后开发中的所有组件
2. 编写组件的相关配置，也就是将组件的json文件中的component字段设为true
```
{
  "component": true,  // 自定义组件声明
  "usingComponents": {} // 可选项，用于引用别的组件
}

```
## 在页面中引入组件
1. 在目标页面json文件中添加配置
```
    "usingComponents": {
        "my-component":"路径"
    }
```
2. 在页面中使用自定义组件
```
 <my-component></my-component>
```
## page与组件的数据交互
- page -> component  WXML数据绑定
1. page在引用组件时能通过属性值设置，component.js在properties获取。
2. page在引用组件时通过data-xxx设置，component.js在this.dataset获取。

- component -> page 事件
1. 组件中的变量要传递到page页面可以通过事件触发this.triggerEvent()

##监听事件
> 事件是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。
1. 自定义组件触发事件
```
methods: {
    onTap: function (){
      var detail = {msg:'来自组件'};
      this.triggerEvent("myEvent",detail); // 触发事件
    }
  }

```
2. 监听事件
当自定义组件触发"myevent"事件时，调用onMyEvent方法

```
    <my-component bindmyEvent="onMyEvent"></my-component>
```

## 自定义组件的生命周期
- 主要的生命周期 
1. created 组件实例刚刚被创建好时，create生命周期被触发。此时，组件数据this.data就是在Component构造器中定义的数据data。此时还不能调用setData。通常情况下，这个生命周期只应该用于给组件this添加一些自定义属性字段。
2. attached 在组件完全初始化完毕、进入页面节点树后。
3. detached 在组件离开页面节点树后

```

Component({
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
  },
  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function() {
    // 在组件实例进入页面节点树时执行
  },
  detached: function() {
    // 在组件实例被从页面节点树移除时执行
  },
  // ...
})
```

## 支付功能
1. wx.login() 
> 调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户的唯一标识（openid）及本次登录的会话密钥（session_key）等。将code发送给后台，用于获取支付时所需的pakeage和paySing值。
2. wx.requestPayment()
```
wx.requestPayment({
  timeStamp: '',
  nonceStr: '',
  package: '',
  signType: 'MD5',
  paySign: '',
  success(res) { },
  fail(res) { }
})
```


